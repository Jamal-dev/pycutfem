Giant package - release 2.3 at September 4, 1991

The GIANT package consists of the files listed and briefly described
below:

filename    contents of file

giant.f     GIANT user interface and internal subroutines,
            Good Broyden internal subroutines,

easypack_giant.f  A package of subroutines supplying standard programs
            for Jacobian times vector multiplication and preconditio-
            ning. Included are interface routines to GIANT. 
            This package allows an easy use of the GIANT program -
            the only users task remaining is to supply the problem
            function and it's Jacobian in a special sparse matrix
            format. 
             This package contains software from SLAP (Sparse Linear
             Algebra Package).
             
linpack_gbit1.f    Linpack and BLAS routines called from EASYPACK.

linalg_giant.f     Internal GBIT1 subroutines, called directly by GIANT.
            
gmres_giant.f     The Generalized Minimum Residual algorithm from the SLAP
            package (slighly modified termination criterium and calls
            of time monitor added)

zibmon.f    Monitor.

zibsec.f    Time routine ZIBSEC.

zibconst.f  Machine constants ZIBCONST.

main_giant1.f    An example main program to illustrate the usage of GIANT
            in connection with EASYPACK.

main_giant2.f    An example main program with a user supplied ("matrix free")
            Jacobian times vector subroutine and a user supplied
            preconditioner. Needs only the subroutines contained in
            giant.f to run.

main_giant3.f    An example main program to illustrate the usage of GIANT
            in connection with EASYPACK and the additionally supplied
            iterative linear solver GMRES (instead of Good Broyden).

makefile    An input file to the UNIX make utility containing infor-
            mation how to build the executable programs giant1, giant2
            and giant3.

readme      This description.

giant1.nrm  Example output to FORTRAN unit 6 of program run of giant1.

giant2.nrm  Example output to FORTRAN unit 6 of program run of giant2.

giant3.nrm  Example output to FORTRAN unit 6 of program run of giant3.


The three main program all solve the same test problem in three
slightly different ways. To build executable programs, you need to
compile and to link:

main_giant1.f, giant.f, easypack_giant.f, zibmon.f, zibsec.f,
     zibconst.f or
main_giant2.f, giant.f, zibmon.f, zibsec.f, zibconst.f or
main_giant3.f, giant.f, easypack_giant.f, gmres_giant.f, zibmon.f,
     zibsec.f, zibconst.f.

Under UNIX with the make-utility, for example simply type in:
make giant1
to build the program giant1.


The remaining part of this document contains a description of the test
example supplied with the main programs giant1, giant2 and giant3.

The nonlinear problem to be solved originates from a boundary value
problem with an elliptical partial differential equation in two
variables x,y , and homogeneous Dirichlet boundary conditions, on the 
rectangle -3 <= x <= 3 and -3 <= y <= 3 . The equation and the boundary
conditions have been discretizised on a homogeneous grid dividing the 
interval from -3 to 3 for each variable in 30 parts, and such
consisting of 31*31=961 grid points. The second order partial deriva-
tives are replaced by the usual second order central difference appro-
ximations. As coded, these approximations are also valid for nonhomo-
geneous grids. Additionally, the example shows up how to include terms
with first order derivatives in the partial differential equation.

The differential equation is:

uxx + uyy + g(u,x,y) = 0 , where

g(u,x,y) := -(9/10*exp(-q(x,y))+1/10*u)*(4*x^2/r1^4 - 2/r1^2
                                        +4*y^2/r2^4 - 2/r2^2)
            +j(ipar)*(exp(u)-exp(exp(-q(x,y)))) ,

with q(x,y) := x^2/r1^2 + y^2/r2^2  and  j(1)=1, j(2)=-1 j(3)=0 .
Herein, r1 and r2 are positive real parameters and ipar is an integer
parameter which may get a value 1, 2 or 3.
In the delivered main programs, r1 is denoted as the variable rpar1 and
r2 as rpar2, and the parameters are set to the values r1=r2=1.0 and 
ipar=2, but these settings may be easily changed in the main program
(Note, that a setting of ipar=1 will cause a divergent iteration of
Good Broyden).

The analytical solution of each of these problems is:

u(x,y) = exp(-q(x,y)) .



 
