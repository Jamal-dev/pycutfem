import numpy as np
from pycutfem.fem.reference.tri_pn import tri_pn
from pycutfem.fem.reference import get_reference

def test_tri_pn_p2_values_at_specific_point():
    """
    Tests the P2 Lagrange basis functions and their derivatives generated by tri_pn
    at a specific point (0.25, 0.25) in the reference element.
    """
    n_order = 2
    ref = get_reference("tri", n_order)

    xi_test, eta_test = 0.25, 0.25

    # Expected P2 Lagrange basis values at (0.25, 0.25)
    # L1=0.5, L2=0.25, L3=0.25
    # N0_V0 = L1*(2*L1-1) = 0.5*(2*0.5-1) = 0.5*(1-1) = 0
    # N1_M01 = 4*L1*L2   = 4*0.5*0.25   = 0.5
    # N2_V1 = L2*(2*L2-1) = 0.25*(2*0.25-1) = 0.25*(0.5-1) = 0.25*(-0.5) = -0.125
    # N3_M02 = 4*L1*L3   = 4*0.5*0.25   = 0.5
    # N4_M12 = 4*L2*L3   = 4*0.25*0.25  = 0.25
    # N5_V2 = L3*(2*L3-1) = 0.25*(2*0.25-1) = 0.25*(-0.5) = -0.125
    expected_N_vals = np.array([0.0, 0.5, -0.125, 0.5, 0.25, -0.125])
    
    actual_N_vals = ref.shape(xi_test, eta_test)
    print(f"shape of arrays: {actual_N_vals.shape}, expected: {expected_N_vals.shape}")
    np.testing.assert_allclose(actual_N_vals, expected_N_vals, atol=1e-9,
                               err_msg="P2 Shape function values at (0.25,0.25) mismatch.")

    # Expected P2 Lagrange gradient dN/dxi at (0.25, 0.25)
    # N0 = L1(2L1-1) = (1-x-y)(2(1-x-y)-1) = (1-x-y)(1-2x-2y)
    #    = 1 -2x -2y -x +2x^2 +2xy -y +2xy +2y^2 = 1 -3x -3y +2x^2 +4xy +2y^2
    # dN0/dx = -3 +4x +4y = -3 + 4(0.25) + 4(0.25) = -3 + 1 + 1 = -1.0
    # N1 = 4L1L2 = 4(1-x-y)x = 4x - 4x^2 - 4xy
    # dN1/dx = 4 - 8x - 4y = 4 - 8(0.25) - 4(0.25) = 4 - 2 - 1 = 1.0
    # N2 = L2(2L2-1) = x(2x-1) = 2x^2 - x
    # dN2/dx = 4x - 1 = 4(0.25) - 1 = 1 - 1 = 0.0
    # N3 = 4L1L3 = 4(1-x-y)y = 4y - 4xy - 4y^2
    # dN3/dx = -4y = -4(0.25) = -1.0
    # N4 = 4L2L3 = 4xy
    # dN4/dx = 4y = 4(0.25) = 1.0
    # N5 = L3(2L3-1) = y(2y-1) = 2y^2 - y
    # dN5/dx = 0
    expected_dNdxi_vals = np.array([-1.0, 1.0, 0.0, -1.0, 1.0, 0.0])
    actual_dNdxi_vals = ref.grad_dxi(xi_test, eta_test)
    np.testing.assert_allclose(actual_dNdxi_vals, expected_dNdxi_vals, atol=1e-9,
                               err_msg="P2 dN/dxi values at (0.25,0.25) mismatch.")

    # Similar checks can be added for dN/deta, Hessian components, and Laplacian
    # For brevity, only N and dN/dxi are fully checked here.

    # Example check for one Laplacian value: N0 = 1 -3x -3y +2x^2 +4xy +2y^2
    # d2N0/dx2 = 4
    # d2N0/dy2 = 4
    # Laplacian(N0) = 4+4 = 8
    expected_lap_N0 = 8.0
    actual_lap_vals = ref.laplacian(xi_test, eta_test)
    np.testing.assert_allclose(actual_lap_vals[0], expected_lap_N0, atol=1e-9,
                               err_msg="P2 Laplacian(N0) at (0.25,0.25) mismatch.")
